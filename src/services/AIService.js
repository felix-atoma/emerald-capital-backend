import { OpenAI } from 'openai';
import { GoogleGenerativeAI } from '@google/generative-ai';
import { Anthropic } from '@anthropic-ai/sdk'; // CORRECTED IMPORT
import config from '../config/config.js'; // Use config instead of dotenv directly

// Initialize AI services
const openai = new OpenAI({
  apiKey: config.openai?.apiKey
});

const genAI = new GoogleGenerativeAI(config.gemini?.apiKey || '');
const anthropic = new Anthropic({
  apiKey: config.claude?.apiKey
});

export class AIService {
  static async generateContent(params, service = 'openai') {
    try {
      let generatedContent = '';
      
      // Check if service is available
      if (service === 'openai' && !config.openai?.apiKey) {
        throw new Error('OpenAI API key not configured');
      }
      if (service === 'gemini' && !config.gemini?.apiKey) {
        throw new Error('Gemini API key not configured');
      }
      if (service === 'claude' && !config.claude?.apiKey) {
        throw new Error('Claude API key not configured');
      }
      
      switch(service) {
        case 'openai':
          generatedContent = await this.generateWithOpenAI(params);
          break;
          
        case 'gemini':
          generatedContent = await this.generateWithGemini(params);
          break;
          
        case 'claude':
          generatedContent = await this.generateWithClaude(params);
          break;
          
        default:
          generatedContent = await this.generateWithOpenAI(params);
      }
      
      return {
        success: true,
        content: generatedContent,
        wordCount: generatedContent.split(/\s+/).length,
        estimatedReadTime: Math.ceil(generatedContent.split(/\s+/).length / 200)
      };
      
    } catch (error) {
      console.error(`AI generation error (${service}):`, error);
      
      // Return mock content if API keys aren't configured
      if (error.message.includes('not configured')) {
        return {
          success: false,
          content: this.generateMockContent(params, service),
          wordCount: 100,
          estimatedReadTime: 1,
          error: error.message
        };
      }
      
      throw new Error(`Failed to generate content with ${service}: ${error.message}`);
    }
  }

  static generateMockContent(params, service) {
    const { title, contentType = 'blog_post', tone = 'professional' } = params;
    
    return `# ${title || 'AI Generated Content'}

## Service: ${service.toUpperCase()}
This is a mock response because ${service} API key is not configured.

## How to Enable Real AI Content:
1. Get your ${service} API key
2. Add it to your .env file as ${service.toUpperCase()}_API_KEY
3. Restart the server

## Mock Content Preview:
This would be a ${tone} ${contentType} about "${title}" generated by ${service}.

*Note: Configure your API keys to enable real AI content generation.*`;
  }

  static async generateWithOpenAI(params) {
    const prompt = this.buildPrompt(params);
    
    const completion = await openai.chat.completions.create({
      model: config.openai?.model || "gpt-4-turbo-preview",
      messages: [
        {
          role: "system",
          content: "You are a professional content writer specializing in creating high-quality, engaging, and SEO-optimized content."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: config.ai?.temperature || 0.7,
      max_tokens: this.getMaxTokens(params.length)
    });

    return completion.choices[0].message.content;
  }

  static async generateWithGemini(params) {
    const model = genAI.getGenerativeModel({ 
      model: config.gemini?.model || "gemini-pro" 
    });
    const prompt = this.buildPrompt(params);
    
    const result = await model.generateContent(prompt);
    const response = await result.response;
    return response.text();
  }

  static async generateWithClaude(params) {
    const prompt = this.buildPrompt(params);
    
    const message = await anthropic.messages.create({
      model: config.claude?.model || "claude-3-opus-20240229",
      max_tokens: this.getMaxTokens(params.length),
      temperature: config.ai?.temperature || 0.7,
      messages: [
        {
          role: "user",
          content: prompt
        }
      ]
    });

    return message.content[0].text;
  }

  static async generateOutline(title, keywords = []) {
    try {
      // Check if OpenAI is configured
      if (!config.openai?.apiKey) {
        const mockOutline = `I. Introduction to ${title}
II. Background and Context
III. Main Concepts
IV. Practical Applications
V. Conclusion`;
        return {
          success: true,
          outline: mockOutline
        };
      }
      
      const prompt = `Create a comprehensive outline for an article titled "${title}". ${
        keywords.length ? `Include these keywords: ${keywords.join(', ')}.` : ''
      } Provide the outline in Roman numeral format with main sections and subsections.`;
      
      const completion = await openai.chat.completions.create({
        model: "gpt-3.5-turbo",
        messages: [{ role: "user", content: prompt }],
        temperature: 0.5,
        max_tokens: 500
      });

      return {
        success: true,
        outline: completion.choices[0].message.content
      };
      
    } catch (error) {
      console.error('Outline generation error:', error);
      throw new Error('Failed to generate outline');
    }
  }

  static async improveContent(content, improvementType = 'grammar') {
    try {
      // Check if OpenAI is configured
      if (!config.openai?.apiKey) {
        return {
          success: true,
          improvedContent: content + `\n\n[Mock ${improvementType} improvement - add OpenAI API key for real improvements]`
        };
      }
      
      const improvementPrompts = {
        grammar: "Fix grammar, spelling, and punctuation errors in the following content:",
        seo: "Optimize the following content for SEO by improving keyword density, adding meta elements, and enhancing readability:",
        tone: "Adjust the tone of the following content to be more professional and authoritative:",
        brevity: "Make the following content more concise while preserving key information:",
        expansion: "Expand the following content with more details, examples, and explanations:"
      };

      const prompt = `${improvementPrompts[improvementType] || improvementPrompts.grammar}\n\n${content}`;
      
      const completion = await openai.chat.completions.create({
        model: "gpt-4",
        messages: [{ role: "user", content: prompt }],
        temperature: 0.3,
        max_tokens: 2000
      });

      return {
        success: true,
        improvedContent: completion.choices[0].message.content
      };
      
    } catch (error) {
      console.error('Content improvement error:', error);
      throw new Error('Failed to improve content');
    }
  }

  static async analyzeContent(content) {
    try {
      // Check if OpenAI is configured
      if (!config.openai?.apiKey) {
        const wordCount = content.split(/\s+/).length;
        return {
          success: true,
          analysis: {
            readability: 75,
            readingTime: Math.ceil(wordCount / 200),
            wordCount: wordCount,
            tone: 'neutral',
            seoScore: 65,
            suggestions: [
              'Add OpenAI API key for detailed analysis',
              'Include more specific examples',
              'Break up long paragraphs'
            ]
          }
        };
      }
      
      const prompt = `Analyze the following content and provide:
1. Readability score (0-100)
2. Estimated reading time (in minutes)
3. Keyword density analysis (top 5 keywords)
4. Tone assessment (professional, casual, technical, etc.)
5. SEO score (0-100) with recommendations
6. Three suggested improvements

Content to analyze:
${content}`;
      
      const completion = await openai.chat.completions.create({
        model: "gpt-4",
        messages: [{ role: "user", content: prompt }],
        temperature: 0.2,
        max_tokens: 1000
      });

      const analysis = this.parseAnalysis(completion.choices[0].message.content);
      
      return {
        success: true,
        analysis
      };
      
    } catch (error) {
      console.error('Content analysis error:', error);
      throw new Error('Failed to analyze content');
    }
  }

  static buildPrompt({ title, keywords, contentType, tone, length, outline }) {
    const toneMap = {
      professional: "Use a professional, authoritative tone suitable for business and technical audiences.",
      conversational: "Use a conversational, friendly tone as if speaking directly to the reader.",
      authoritative: "Use an authoritative, expert tone backed by data and research.",
      friendly: "Use a warm, approachable, and friendly tone.",
      technical: "Use a precise, technical tone with industry terminology and specifications."
    };

    const lengthMap = {
      short: "Create a concise piece of about 300-500 words.",
      medium: "Create a comprehensive piece of about 500-1000 words.",
      long: "Create an in-depth piece of about 1000-2000 words.",
      comprehensive: "Create a thorough, detailed piece of 2000+ words."
    };

    const typeMap = {
      blog_post: "Write a well-structured blog post with introduction, body, and conclusion.",
      article: "Write a formal article with proper headings, subheadings, and sections.",
      social_media: "Create engaging social media content suitable for platforms like LinkedIn, Twitter, and Facebook.",
      meta_description: "Write a compelling meta description (150-160 characters) for SEO purposes.",
      email_newsletter: "Draft a newsletter email with a catchy subject line and engaging body content."
    };

    return `
Create content with the following specifications:

Title: ${title}
${keywords?.length ? `Keywords: ${keywords.join(', ')}` : ''}
Content Type: ${typeMap[contentType] || typeMap.blog_post}
Tone: ${toneMap[tone] || toneMap.professional}
Length: ${lengthMap[length] || lengthMap.medium}
${outline ? `Use this outline structure:\n${outline}` : ''}

Requirements:
- Include relevant keywords naturally
- Use proper formatting with headings
- Add actionable insights
- Include examples where appropriate
- End with a strong conclusion
- Ensure SEO optimization
- Make it engaging and valuable
- Avoid fluff and repetition

Start generating the content now:
    `.trim();
  }

  static getMaxTokens(length) {
    const tokenMap = {
      short: 1000,
      medium: 1500,
      long: 2000,
      comprehensive: 4000
    };
    return tokenMap[length] || 1500;
  }

  static parseAnalysis(text) {
    const analysis = {
      readability: 0,
      readingTime: 0,
      wordCount: 0,
      keywordDensity: {},
      tone: '',
      seoScore: 0,
      suggestions: []
    };

    // Parse readability score
    const readabilityMatch = text.match(/Readability score.*?(\d+)/i);
    if (readabilityMatch) analysis.readability = parseInt(readabilityMatch[1]);

    // Parse reading time
    const readingTimeMatch = text.match(/reading time.*?(\d+)/i);
    if (readingTimeMatch) analysis.readingTime = parseInt(readingTimeMatch[1]);

    // Parse word count
    const wordCountMatch = text.match(/Word count.*?(\d+)/i);
    if (wordCountMatch) analysis.wordCount = parseInt(wordCountMatch[1]);

    // Parse tone
    const toneMatch = text.match(/Tone.*?:\s*([^\n]+)/i);
    if (toneMatch) analysis.tone = toneMatch[1].trim();

    // Parse SEO score
    const seoScoreMatch = text.match(/SEO score.*?(\d+)/i);
    if (seoScoreMatch) analysis.seoScore = parseInt(seoScoreMatch[1]);

    // Parse keyword density
    const keywordSection = text.match(/Keyword density.*?(?=Tone|SEO|Suggestions)/is);
    if (keywordSection) {
      const keywordLines = keywordSection[0].match(/\d+%[^:]*:[^%\n]*/g);
      if (keywordLines) {
        keywordLines.forEach(line => {
          const match = line.match(/(\d+)%\s*([^:]+):\s*(.+)/);
          if (match) {
            analysis.keywordDensity[match[2].trim()] = {
              percentage: parseInt(match[1]),
              description: match[3].trim()
            };
          }
        });
      }
    }

    // Parse suggestions
    const suggestionLines = text.match(/-\s*([^\n]+)/g);
    if (suggestionLines) {
      analysis.suggestions = suggestionLines.map(line => line.replace(/^-\s*/, '').trim());
    }

    return analysis;
  }

  static calculateCredits(wordCount) {
    return Math.ceil(wordCount / 100); // 1 credit per 100 words
  }

  static validateAPIKeys() {
    console.log('ü§ñ AI Service Status:');
    console.log(`- OpenAI: ${config.openai?.apiKey ? '‚úÖ Available' : '‚ùå Not configured'}`);
    console.log(`- Gemini: ${config.gemini?.apiKey ? '‚úÖ Available' : '‚ùå Not configured'}`);
    console.log(`- Claude: ${config.claude?.apiKey ? '‚úÖ Available' : '‚ùå Not configured'}`);
    
    const anyAvailable = !!(config.openai?.apiKey || config.gemini?.apiKey || config.claude?.apiKey);
    
    if (!anyAvailable) {
      console.warn('‚ö†Ô∏è No AI API keys configured. AI features will use mock responses.');
    }
    
    return anyAvailable;
  }
}

export default AIService;